SAVE_STATE MACRO
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
ENDM

LOAD_STATE MACRO
	POP	DX
	POP	CX
	POP	BX
	POP	AX
ENDM

PUTCHAR	MACRO CHAR
	PUSH 	AX
	MOV	AL, CHAR
	INT	29H
	POP	AX
ENDM

PUTSTR MACRO STR
	PUSH	AX
	PUSH	DX
	MOV	AH, 09H
	LEA	DX, STR
	INT	21H
	POP	DX
	POP	AX
ENDM

PUTENDL MACRO
	PUTCHAR	0DH
	PUTCHAR	0AH
ENDM

GETCHAR MACRO
	PUSH	AX
	MOV	AH, 08H
	INT	21H
	POP	AX
ENDM

GETSTR MACRO BUFF
	PUSH	AX
	PUSH	DX
	LEA	DX, BUFF
	MOV	AH, 0AH
	INT	21H
	PUTENDL
	POP	DX
	POP	AX
ENDM

STSEG SEGMENT PARA STACK "STACK"
	DB 64 DUP ("STACK")
STSEG ENDS

DSEG SEGMENT PARA PUBLIC "DATA"
	INPUT_MSG 	DB "Enter number:$"
	ERR_INV_MSG 	DB "Number is invalid.$"
	ERR_OF_MSG 	DB "Number is too big.$"
	EL_PROMPT	DB "Enter element: $"
	LEN_PROMPT	DB "Enter the length of the array (255 or less).$"
;	SEARCH_PROMPT	DB "Enter number to search in a 2D array: $"
;	N_PROMPT	DB "Enter the length of strings in a 2D array.$"
	QUANT_ERR_MSG	DB "There must be 2 or more element, but less than 256.$"
	SUM_MSG		DB "Sum: $"
	MAX_MSG		DB "Max element: $"
	MIN_MSG		DB "Min element: $"
	YOUR_ARR_MSG	DB "Your array:$"
;	YOUR_2D_ARR_MSG	DB "Your 2D array:$"
	SORTED_MSG	DB "Sorted array:$"
;	COORDS_MSG	DB "Coordinates:$"
;	NOT_FOUND_MSG	DB "Element was not found.$"
	BUFF 		DB 7, ?, 7 DUP ('?')
	IS_NEG 		DB 0
	IS_ERR 		DB 0
;	IS_FOUND	DB 0
	NUM 		DW 0
	ARR_LEN 	DB 0
;	N 		DW 0
;	NUM_TO_SEARCH 	DW 0
	ARRAY 		DW 255 DUP(0)
DSEG ENDS

CSEG SEGMENT PARA PUBLIC "CODE"
	ASSUME CS: CSEG, DS: DSEG, SS: STSEG

	ATOI PROC NEAR
		SAVE_STATE

		LEA 	DI, BUFF + 2
		MOV 	CL, [DI]
		CMP 	CL, '-'
		JE 	ATOI_NEG
		CMP 	CL, '+'
		JE 	ATOI_POS
		
	ATOI_INIT:
		XOR 	BX, BX
		MOV	BX, 10
		XOR	AX, AX

	ATOI_LOOP:
		XOR 	CX, CX
		MOV	CL, [DI]
		CMP	CL, 0DH
		JE 	ATOI_END
		CMP	CL, 30H
		JB	ATOI_ERR_INV
		CMP	CL, 39H
		JA	ATOI_ERR_INV
		SUB	CL, 30H
		MUL	BX
		JC	ATOI_ERR_OF
		ADD	AX, CX
		JC 	ATOI_ERR_OF
		INC	DI
		JMP	ATOI_LOOP

	ATOI_NEG:
		PUSH 	AX
		MOV	AL, 1
		MOV	IS_NEG, AL
		POP	AX
		INC 	DI
		JMP	ATOI_INIT

	ATOI_POS:

		PUSH 	AX
		MOV	AL, 0
		MOV	IS_NEG, AL
		POP	AX
		INC	DI
		JMP	ATOI_INIT

	ATOI_ERR_INV:
		MOV	AL, 1
		MOV	IS_ERR, AL
		PUTSTR 	ERR_INV_MSG
		PUTENDL
		JMP	ATOI_QUIT

	ATOI_ERR_OF:
		MOV	AL, 1
		MOV	IS_ERR, AL
		PUTSTR 	ERR_OF_MSG
		PUTENDL
		JMP	ATOI_QUIT

	ATOI_END:
		CMP	AX, 32768
		JA	ATOI_ERR_OF
		MOV	CL, IS_NEG
		CMP	CL, 1
		JNZ	ATOI_QUIT
		NEG	AX

	ATOI_QUIT:
		MOV	NUM, AX
		LOAD_STATE
		RET	
	ATOI ENDP

	ITOA PROC NEAR
		SAVE_STATE

		MOV 	BX, NUM
		OR	BX, BX
		JNS	ITOA_POS
		PUTCHAR '-'
		NEG	BX
	ITOA_POS:
		MOV	AX, BX
		XOR	CX, CX
		MOV	BX, 10
	ITOA_PARSE_LOOP:
		XOR	DX, DX
		DIV	BX
		ADD	DL, '0'
		PUSH	DX
		INC	CX
		TEST	AX, AX
		JNZ ITOA_PARSE_LOOP
	ITOA_END_LOOP:
		POP AX
		INT 29H
		LOOP ITOA_END_LOOP
		LOAD_STATE
		RET
	ITOA ENDP

	INIT_ARR PROC NEAR
		SAVE_STATE

		MOV	SI, OFFSET ARRAY
		XOR	CX, CX
		MOV	CL, ARR_LEN
	INIT_LOOP:
		PUTSTR	EL_PROMPT
		GETSTR	BUFF
		CALL	ATOI
		CMP	IS_ERR, 1
		JE	INIT_END
		XOR	AX, AX
		MOV	AX, NUM
		MOV	[SI], AX
		ADD	SI, 2
		LOOP	INIT_LOOP
	INIT_END:
		POP	DX
		POP	CX
		POP	BX
		POP	AX
		RET
	INIT_ARR ENDP

	PRINT_ARR PROC NEAR
		PUSH	AX
		PUSH	BX
		PUSH	CX
		PUSH	DX

		MOV	SI, OFFSET ARRAY
		XOR	CX, CX
		MOV	CL, ARR_LEN
	PRINT_LOOP:
		MOV	BX, [SI]
		MOV	NUM, BX
		CALL	ITOA
		PUTCHAR	' '
		ADD	SI, 2
		LOOP	PRINT_LOOP

		LOAD_STATE
		RET
	PRINT_ARR ENDP

	ARR_SUM PROC NEAR
		SAVE_STATE

		MOV	SI, OFFSET ARRAY
		XOR	AX, AX
		XOR	CX, CX
		MOV	CL, ARR_LEN
	SUM_LOOP:
		MOV	BX, [SI]
		ADD	AX, BX
		ADD	SI, 2
		LOOP	SUM_LOOP
		MOV	NUM, AX

		LOAD_STATE
		RET
	ARR_SUM ENDP

	ARR_MAX PROC NEAR
		SAVE_STATE

		MOV	SI, OFFSET ARRAY
		XOR	AX, AX
		XOR	CX, CX
		MOV	AX, [SI]
		MOV	CL, ARR_LEN
		SUB	CX, 1
	MAX_LOOP:
		ADD	SI, 2
		CMP	AX, [SI]
		JGE	MAX_CONTINUE
		MOV	AX, [SI]
	MAX_CONTINUE:
		LOOP	MAX_LOOP
		MOV	NUM, AX

		LOAD_STATE
		RET	
	ARR_MAX ENDP
	
	ARR_MIN PROC NEAR
		SAVE_STATE

		MOV	SI, OFFSET ARRAY
		XOR	AX, AX
		XOR	CX, CX
		MOV	AX, [SI]
		MOV	CL, ARR_LEN
		SUB	CX, 1
	MIN_LOOP:
		ADD	SI, 2
		CMP	AX, [SI]
		JLE	MIN_CONTINUE
		MOV	AX, [SI]
	MIN_CONTINUE:
		LOOP	MIN_LOOP
		MOV	NUM, AX

		LOAD_STATE
		RET	
	ARR_MIN ENDP

	ARR_SORT PROC NEAR
		SAVE_STATE

		MOV	SI, OFFSET ARRAY
		MOV	DI, OFFSET ARRAY
		XOR	CX, CX
		MOV	CL, ARR_LEN
		SHL	CX, 1
		ADD	DI, CX
		SUB	DI, 2
		SHR	CX, 1
	ARR_LOOP:
		CMP	SI, DI
		JE	ARR_END
		MOV	AX, [SI]
		MOV	BX, [SI + 2]
		CMP	AX, BX
		JLE	ARR_CONTINUE
		MOV	[SI + 2], AX
		MOV	[SI], BX
		MOV	CL, ARR_LEN
		MOV	SI, OFFSET ARRAY
		JMP	ARR_LOOP
	ARR_CONTINUE:
		ADD	SI, 2
		LOOP	ARR_LOOP
	ARR_END:
		LOAD_STATE
		RET
	ARR_SORT ENDP

	MAIN PROC FAR
		PUSH	DS
		XOR 	AX, AX
		PUSH 	AX
		MOV 	AX, DSEG
		MOV	DS, AX

		PUTSTR 	LEN_PROMPT
		PUTENDL
		GETSTR	BUFF
		CALL	ATOI
		CMP	IS_ERR, 1
		JNE	CHECK_NUM
		JMP	MAIN_END
	CHECK_NUM:
		CMP	NUM, 1
		JLE	QUANT_ERR
		CMP	NUM, 255
		JLE	CONTINUE	
	QUANT_ERR:
		PUTSTR	QUANT_ERR_MSG
		JMP	MAIN_END
	CONTINUE:
		XOR	AX, AX
		MOV	AX, NUM
		MOV	ARR_LEN, AL
		CALL	INIT_ARR
		CMP	IS_ERR, 1
		JNE	CONT_INIT
		JMP	MAIN_END
	CONT_INIT:
		PUTSTR	YOUR_ARR_MSG
		PUTENDL
		CALL	PRINT_ARR
		PUTENDL
		PUTSTR	SUM_MSG
		CALL	ARR_SUM
		CALL	ITOA
		PUTENDL
		PUTSTR	MAX_MSG
		CALL	ARR_MAX
		CALL	ITOA
		PUTENDL
		PUTSTR	MIN_MSG
		CALL	ARR_MIN
		CALL	ITOA
		PUTENDL
		CALL	ARR_SORT
		PUTSTR	SORTED_MSG
		PUTENDL
		CALL	PRINT_ARR
	;	XOR	AX, AX
	;	XOR	BX, BX
	;	XOR	SI, SI
	;	MOV	BX, 4
	;	MOV	SI, 2
	;	MOV	AX, ARRAY[BX][SI]
	;	MOV	NUM, AX
	;	CALL	ITOA
	MAIN_END:
		GETCHAR
		RET
	MAIN ENDP
CSEG ENDS

END MAIN