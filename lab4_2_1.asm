SAVE_STATE MACRO
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
ENDM

LOAD_STATE MACRO
	POP	DX
	POP	CX
	POP	BX
	POP	AX
ENDM

PUTCHAR	MACRO CHAR
	PUSH 	AX
	MOV	AL, CHAR
	INT	29H
	POP	AX
ENDM

PUTSTR MACRO STR
	PUSH	AX
	PUSH	DX
	MOV	AH, 09H
	LEA	DX, STR
	INT	21H
	POP	DX
	POP	AX
ENDM

PUTENDL MACRO
	PUTCHAR	0DH
	PUTCHAR	0AH
ENDM

GETCHAR MACRO
	PUSH	AX
	MOV	AH, 08H
	INT	21H
	POP	AX
ENDM

GETSTR MACRO BUFF
	PUSH	AX
	PUSH	DX
	LEA	DX, BUFF
	MOV	AH, 0AH
	INT	21H
	PUTENDL
	POP	DX
	POP	AX
ENDM

GETLEN MACRO N, M
	PUSH	AX
	PUSH	BX
	XOR	AX, AX
	XOR	BX, BX
	MOV	AX, N
	MOV	BX, M
	MUL	BX
	MOV	ARR_LEN, AL
	POP	BX
	POP	AX
ENDM

STSEG SEGMENT PARA STACK "STACK"
	DB 64 DUP ("STACK")
STSEG ENDS

DSEG SEGMENT PARA PUBLIC "DATA"
	INPUT_MSG 	DB "Enter number:$"
	ERR_INV_MSG 	DB "Number is invalid.$"
	ERR_OF_MSG 	DB "Number is too big.$"
	FIRST_ROW_MSG	DB "Enter row #1.$"
	NEW_ROW_MSG	DB "Enter row #$"
	EL_PROMPT	DB "Enter element: $"
	N_PROMPT	DB "Enter the number of rows of the array:$"
	M_PROMPT	DB "Enter the number of columns of the array:$"
	SEARCH_PROMPT	DB "Enter number to search in a 2D array: $"
	QUANT_ERR_N_MSG	DB "There must be 2 or more element, but less than 256.$"
	QUANT_ERR_M_MSG	DB "You've either entered less than 1 (array can't have 0 or less elements) or number of elements has exceeded 255.$"
	YOUR_2D_ARR_MSG	DB "Your 2D array:$"
	COORDS_MSG	DB "Coordinates:$"
	NOT_FOUND_MSG	DB "Element was not found.$"
	BUFF 		DB 7, ?, 7 DUP ('?')
	IS_NEG 		DB 0
	IS_ERR 		DB 0
	IS_FOUND	DB 0
	NUM 		DW 0
	ARR_LEN 	DB 0
	N 		DW 0
	M		DW 0
	NUM_TO_SEARCH 	DW 0
	ARRAY 		DW 255 DUP(0)
DSEG ENDS

CSEG SEGMENT PARA PUBLIC "CODE"
	ASSUME CS: CSEG, DS: DSEG, SS: STSEG

	ATOI PROC NEAR
		SAVE_STATE

		LEA 	DI, BUFF + 2
		MOV 	CL, [DI]
		CMP 	CL, '-'
		JE 	ATOI_NEG
		CMP 	CL, '+'
		JE 	ATOI_POS
		
	ATOI_INIT:
		XOR 	BX, BX
		MOV	BX, 10
		XOR	AX, AX

	ATOI_LOOP:
		XOR 	CX, CX
		MOV	CL, [DI]
		CMP	CL, 0DH
		JE 	ATOI_END
		CMP	CL, 30H
		JB	ATOI_ERR_INV
		CMP	CL, 39H
		JA	ATOI_ERR_INV
		SUB	CL, 30H
		MUL	BX
		JC	ATOI_ERR_OF
		ADD	AX, CX
		JC 	ATOI_ERR_OF
		INC	DI
		JMP	ATOI_LOOP

	ATOI_NEG:
		PUSH 	AX
		MOV	AL, 1
		MOV	IS_NEG, AL
		POP	AX
		INC 	DI
		JMP	ATOI_INIT

	ATOI_POS:

		PUSH 	AX
		MOV	AL, 0
		MOV	IS_NEG, AL
		POP	AX
		INC	DI
		JMP	ATOI_INIT

	ATOI_ERR_INV:
		MOV	AL, 1
		MOV	IS_ERR, AL
		PUTSTR 	ERR_INV_MSG
		PUTENDL
		JMP	ATOI_QUIT

	ATOI_ERR_OF:
		MOV	AL, 1
		MOV	IS_ERR, AL
		PUTSTR 	ERR_OF_MSG
		PUTENDL
		JMP	ATOI_QUIT

	ATOI_END:
		CMP	AX, 32768
		JA	ATOI_ERR_OF
		MOV	CL, IS_NEG
		CMP	CL, 1
		JNZ	ATOI_QUIT
		NEG	AX

	ATOI_QUIT:
		MOV	NUM, AX
		LOAD_STATE
		RET	
	ATOI ENDP

	ITOA PROC NEAR
		SAVE_STATE

		MOV 	BX, NUM
		OR	BX, BX
		JNS	ITOA_POS
		PUTCHAR '-'
		NEG	BX
	ITOA_POS:
		MOV	AX, BX
		XOR	CX, CX
		MOV	BX, 10
	ITOA_PARSE_LOOP:
		XOR	DX, DX
		DIV	BX
		ADD	DL, '0'
		PUSH	DX
		INC	CX
		TEST	AX, AX
		JNZ ITOA_PARSE_LOOP
	ITOA_END_LOOP:
		POP AX
		INT 29H
		LOOP ITOA_END_LOOP
		LOAD_STATE
		RET
	ITOA ENDP

	INIT_2D_ARR PROC NEAR
		SAVE_STATE

		MOV	SI, OFFSET ARRAY
		XOR	AX, AX
		XOR	CX, CX
		XOR	BX, BX
		MOV	CL, ARR_LEN
		MOV	BX, M
	INIT_LOOP:
		PUSH	AX
		DIV	BL
		CMP	AH, 0
		JNE	INIT_OLD_ROW
		PUTSTR	NEW_ROW_MSG
		XOR	DX, DX
		MOV	DL, AL
	; инкрементирую результат деления на кол-во столбцов (то есть, первый индекс массива)
		INC	DL
		MOV	NUM, DX
		CALL	ITOA
		PUTCHAR	'.'
		PUTENDL
	INIT_OLD_ROW:
		PUTSTR	EL_PROMPT
		GETSTR	BUFF
		CALL	ATOI
		CMP	IS_ERR, 1
		JE	INIT_END
		XOR	AX, AX
		MOV	AX, NUM
		MOV	[SI], AX
		ADD	SI, 2
		POP	AX
		INC	AX
		LOOP	INIT_LOOP
	INIT_END:
		LOAD_STATE
		RET
	INIT_2D_ARR ENDP

	PRINT_2D_ARR PROC NEAR
		SAVE_STATE

		MOV	SI, OFFSET ARRAY
		XOR	CX, CX
		MOV	CL, ARR_LEN
		XOR	DX, DX
		MOV	DX, M
		XOR	AX, AX
		INC	AX
	PRINT_2D_LOOP:
		MOV	BX, [SI]
		MOV	NUM, BX
		CALL	ITOA
		PUTCHAR	' '
		PUSH	AX
		DIV	DL
		CMP	AH, 0
		JNE	PRINT_CONTINUE
		PUTENDL
	PRINT_CONTINUE:
		ADD	SI, 2
		POP	AX
		INC	AX
		LOOP	PRINT_2D_LOOP

		LOAD_STATE
		RET
	PRINT_2D_ARR ENDP	

	FIND_COORDS PROC NEAR
		SAVE_STATE

		MOV	SI, OFFSET ARRAY
		MOV	BX, M
		XOR	CX, CX
		MOV	CL, ARR_LEN
		XOR	AX, AX
		XOR	DX, DX
		MOV	DX, NUM_TO_SEARCH
	FIND_LOOP:
		CMP	[SI], DX
		JNE	FIND_CONTINUE
		PUSH	AX
		XOR	Ax, AX
		MOV	AL, 1
		MOV	IS_FOUND, AL
		XOR	Ax, AX
		POP	AX
		PUSH	AX
		DIV	BL
		PUTCHAR	'('
		PUSH	DX
		XOR	DX, DX
		MOV	DL, AL
	; инкрементирую результат деления на кол-во столбцов (то есть, первый индекс массива)
		INC	DL
		MOV	NUM, DX
		CALL	ITOA
		PUTCHAR	';'
		XOR	DX, DX
		MOV	DL, AH
	; инкрементирую остаток от деления на кол-во столбцов (то есть, второй индекс массива)
		INC	DL
		MOV	NUM, DX
		CALL ITOA
		PUTCHAR	')'
		PUTENDL
		XOR	DX, DX
		POP	DX
		XOR	AX, AX
		POP	AX
	FIND_CONTINUE:
		ADD 	SI, 2
		INC	AX
		LOOP	FIND_LOOP

		CMP	IS_FOUND, 0
		JNE	FIND_END
		PUTSTR	NOT_FOUND_MSG
	FIND_END:
		LOAD_STATE
		RET
	FIND_COORDS ENDP

	MAIN PROC FAR
		PUSH	DS
		XOR 	AX, AX
		PUSH 	AX
		MOV 	AX, DSEG
		MOV	DS, AX

		PUTSTR	N_PROMPT
		PUTENDL
		GETSTR	BUFF
		CALL	ATOI
		CMP	IS_ERR, 1
		JNE	CHECK_N
		JMP	MAIN_END
	CHECK_N:
		CMP	NUM, 1
		JLE	QUANT_ERR_N
		CMP	NUM, 255
		JLE	CONTINUE_INIT
	QUANT_ERR_N:
		PUTSTR	QUANT_ERR_N_MSG
		JMP	MAIN_END	
	CONTINUE_INIT:
		XOR	AX, AX
		MOV	AX, NUM
		MOV	N, AX

		PUTSTR	M_PROMPT
		PUTENDL
		GETSTR	BUFF
		CALL	ATOI
		CMP	IS_ERR, 1
		JNE	CHECK_M
		JMP	MAIN_END
	CHECK_M:
		CMP	NUM, 1
		JL	QUANT_ERR_M
		XOR	AX, AX
		XOR	BX, BX
		MOV	AX, N
		MOV	BX, NUM
		MUL	BX
		CMP	AX, 255
		JLE	CONTINUE
	QUANT_ERR_M:
		PUTSTR	QUANT_ERR_M_MSG
		JMP	MAIN_END
	CONTINUE:
		XOR	AX, AX
		MOV	AX, NUM
		MOV	M, AX

		GETLEN	N, M
		CALL	INIT_2D_ARR

		PUTSTR 	YOUR_2D_ARR_MSG
		PUTENDL
		CALL	PRINT_2D_ARR

		PUTSTR	SEARCH_PROMPT
		PUTENDL
		GETSTR	BUFF
		CALL	ATOI
		CMP	IS_ERR, 1
		JE	MAIN_END
		XOR	AX, AX
		MOV	AX, NUM
		MOV	NUM_TO_SEARCH, AX
		PUTSTR	COORDS_MSG
		PUTENDL
		CALL	FIND_COORDS
	MAIN_END:
		GETCHAR
		RET
	MAIN ENDP
CSEG ENDS

END MAIN